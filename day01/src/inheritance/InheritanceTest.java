package inheritance;
	// 클래스는 여러개 한꺼번에 만들수 있다.
	// 클래스(=필드)A볼때, 앞서 본, 3g핸드폰이라고 생각해자=생성자
	// 따라서 핸드폰 여러개 있듯이 생성자도 여러개 있을 수 있다.
	// 생성자는 return값이 없다. 그 이유는 생성자는 return값을 낼때, 주소를 호출하기 때문이다.

//------------------------------------------------------------------------
class A {
	 // 만약 얘를 둘다 초기화하는 생성자를 만들고 싶다고 할떄,
	 // 생성자를 A에다가 하면, 메모리 낭비가 된다.
	 String name = "타노스";
	 int data = 10;
	 
	 
	 // 기본생성자, 증명
	 // 부모 생성자와 자식생성자 중 누가 먼저 올라 갈까요? 상식적으로 부모 같은데, 한번 확인해보자.
	 public A() {
		 System.out.println("부모 생성자 호출");// 부모 생성자가 잘 호출되는지 보기 위해 43행에 super();로 호출해본거
	 }
//	 			r string name은 매개변수이다.
	 public A(String name) {
		 this.name = name;
	 }
	 // 똑같은 이름으로 여러개의 메소드를 만들 수 있는 친구-> ★다형성 중에서 오버로딩
	 // 다형성 = 오버로딩(메소드 이름이 똑같은데, 형태가 달라서 어떤걸 할건지 알 수 있다.
	 // 재정의 = 오버라이딩, 
	 // 덮어쓰기(부모생성자에 만들어져 있는데, 자식생성자에서 내가 독자적으로 사용하고 싶다고 할때)
	 // 안쓰고 싶어서, 안가져 가고 싶은데, 가져가면 메모리 낭비인데 할때~! 오버로딩으로 덮어쓰기 해주는 것.
	 // 부모 생성자일때는, 그대로 오버로딩 전에 것 출력, 자식 생성자는 오버로딩 후에 것 출력
	 void printName() {
		 System.out.println(name);
	 }
			 
}

//------------------------------------------------------------------------
// 얘를 4g핸드폰이라고 생각하고, 이미지화 하면서 해보자, 
// 기본생성자를 사용해서 메모리에 올렸고, 그래서 사용할 수 있는 것

	// 모양 1
class B extends A {// ★멤버 변수가 하나도 없음! 부모거 쓰고 있기 때문

	public B() {
		 // 부모생성자 // 자식생성자가 호출될때, 무조건 부모생성자가 먼저 호출되는 것
		super(); //-> 부모 생성자	// super();  =  부모 생성자를 강제로 호출해보는 것. // 그래서 이 친구를 밑으로 내리면 에러가 난다. 
		 System.out.println("자식 생성자 호출");// ★무조건 부모생성자가 먼저 호출된 이후에 자식생성자가 호출됨.
	 }
	 
	 // (50~52)부모에 있는 멤버 변수를 그대로 자식에서도 사용할 수 있는지 체크
	 public B(String name, int data) { // 부모
		 this.name = name; 
		 this.data = data;
	 }
	 
	 void printData() {
		 System.out.println(name);
		 System.out.println(data);
	 }
}
	//  ▶모양2

//	public B() {;}

//	public B(String name) {// B라는 클래스를 만들면서 부모 생성자를 호출할 때 매개변수 하나를 가지고 name하나만 초기화하는거,
//		이미 하나를 만들어 놨기때무네 위에 부모 필드에서 가져올수도 있어야 하는거
//		부모에서 생성자가 안만들어져 있으면, 그냥 필드에서 초기화 할 수도 있어야 하는 거
//		// 자식생성자가 호출될때, 무조건 부모생성자가 먼저 호출되는 것
//		// super(); =  부모 생성자를 강제로 호출해보는 것.
//		super(name); 
//		// super();는 생략 됨. 그리고 반드시 부모가 먼저 올라가야한다.
//		// 그래서 이 친구를 밑으로 내리면 에러가 난다. 
//		System.out.println("자식 생성자 호출");
//	}
//	
//	public B(String name, int data) {
//		this.name = name;
//		this.data = data;
//	}
//}

//-----------------------------------------------------

public class InheritanceTest {
	public static void main(String[] args) {
		// ▶★B를 객체화 시키는 단계
		// 부모의 필드를 자식에게 사용하고 있는거
		B b = new B();
		b.printName();
		// 부모의 데이터지만, 상속된다고 생각하고 사용해도 되는 거임.
		System.out.println(b.data);
		
		B b2 = new B("안민정", 33);
		b2.printData();
	}//클래스 중괄호
}//패키지 중괄호
//--------------------------------------------------------------

// 생성자는 무조건 하나가 있어야 하는게 아니라 여러개 있어도 된다.
// 생성자는 클래스 이름을 가지고 메모리를 할당하는 것
// 클래스 이름으로 메소드를 만들어 둔 것.
// 생성자는 리턴값이 아예 없다. 무조건 주소값을 리턴해주는 친구이기 때문이다.
//클래스를 만들게 되면 무조건 생성자를 호출하여 메모리에 올려줘야. 객체를 만들어 거기 안에 잇는 필드로 사용할 수 있다
//그 객체는 메모리에 할당되면서 부여받은 주소를 담고 있다.



// 자식 클래스는 부모 클래스보다 크기가 항상 크다!
//